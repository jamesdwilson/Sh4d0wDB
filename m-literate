#!/usr/bin/env python3
"""
m â€” ShadowDB Memory Search & Operations CLI
=============================================

This is the LITERATE version â€” every function, every line is documented.
The production version (`m`) is identical in behavior but minified for speed.

WHAT THIS SCRIPT DOES:

    Your AI agent's entire configuration is 11 bytes:

        DB: m query

    The agent reads that, runs `m`, and gets its identity + knowledge from
    a database. Zero static files. Zero per-turn waste.

    This script is the `m` command. It does two things:

        1. SEARCH:  Find knowledge by keyword + meaning (hybrid search)
        2. OPERATE: Save records, check loops, manage session state


SUBCOMMANDS:

    m "query"                          Search the knowledge base
    m save "title" "content"           Save a new record
    m loops                            Show open loops / nags / deadlines
    m state [key] [value]              Read or write session state
    m people [name]                    Lookup contacts
    m handoff "focus" ["drafts"]       Write session handoff state
    m d                                Daily dashboard (state + loops + recent)


BACKEND RESOLUTION:

    The script figures out which database to use automatically:

        1. --backend flag              (explicit override)
        2. SHADOWDB_BACKEND env var    (per-session config)
        3. ~/.shadowdb.json config     (persistent preference)
        4. Auto-detect                 (try postgres, then sqlite)


SEARCH PIPELINE (PostgreSQL):

    query
      â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  FTS (tsvector/tsquery)    Vector (pgvector)    â”‚
    â”‚  GIN index, stemming       HNSW index, cosine   â”‚
    â”‚  top 50 keyword matches    top 50 semantic hits  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†“                            â†“
    Reciprocal Rank Fusion (k=60)
      â†“
    top N results (default 5)


WHY psql SUBPROCESS (NOT psycopg2):

    Zero pip dependencies. No virtualenv. No setup.py. Just Python stdlib.
    The ~5ms overhead per subprocess is negligible at our query rate.


CONFIG FILE (~/.shadowdb.json):

    {
        "backend": "postgres",
        "postgres": {
            "psql_path": "/opt/homebrew/opt/postgresql@17/bin/psql",
            "database": "shadow",
            "embedding_url": "http://localhost:11434/api/embeddings",
            "embedding_model": "nomic-embed-text"
        }
    }


SEE ALSO:

    m                   â€” Production version (minified, same behavior)
    backends/           â€” Database adapters (postgres, sqlite, mysql)
    quickstart.sh       â€” One-command setup
    README.md           â€” Full documentation + architecture
"""

import argparse
import json
import os
import sys
import subprocess


# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                           CONFIGURATION                                    â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CONFIG_PATH = os.path.expanduser("~/.shadowdb.json")


def load_config():
    """
    Load settings from ~/.shadowdb.json.

    Returns an empty dict if the file doesn't exist. This is intentional â€”
    missing config means "use defaults and auto-detect." A new user who
    just ran quickstart.sh should be able to type `m "test"` immediately.

    Returns:
        dict: Parsed config, or {} if no config file.
    """
    if os.path.exists(CONFIG_PATH):
        with open(CONFIG_PATH) as f:
            return json.load(f)
    return {}


# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                         BACKEND RESOLUTION                                 â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
#   Four-step chain to determine which database to use:
#
#     1. --backend flag          (highest priority â€” explicit user choice)
#     2. SHADOWDB_BACKEND env    (useful for per-agent config)
#     3. ~/.shadowdb.json        (persistent preference)
#     4. Auto-detect             (try postgres first, then sqlite)


def resolve_backend(override=None):
    """
    Determine which database backend to use and return an instantiated adapter.

    Args:
        override: Backend name from --backend flag (e.g., "postgres").
                  None means "figure it out automatically."

    Returns:
        A backend object with .startup() and .search() methods.
    """
    config = load_config()

    # Step 1: CLI override
    name = override

    # Step 2: Environment variable
    if not name:
        name = os.environ.get("SHADOWDB_BACKEND")

    # Step 3: Config file
    if not name:
        name = config.get("backend")

    # Step 4: Auto-detect
    if not name:
        name = auto_detect_backend(config)

    return create_backend(name, config)


def auto_detect_backend(config):
    """
    Try to connect to PostgreSQL. If that fails, fall back to SQLite.

    PostgreSQL is tried first because it's the most capable backend
    (hybrid FTS + vector search + RRF fusion). SQLite is the fallback
    because it requires zero infrastructure.

    Args:
        config: The loaded config dict (for psql path and database name).

    Returns:
        str: "postgres" or "sqlite"
    """
    psql_path = config.get("postgres", {}).get("psql_path", "psql")
    database = config.get("postgres", {}).get("database", "shadow")

    try:
        result = subprocess.run(
            [psql_path, database, "-t", "-A", "-c", "SELECT 1;"],
            capture_output=True,
            text=True,
            timeout=3,
        )
        if result.returncode == 0:
            return "postgres"
    except Exception:
        pass

    # Check if SQLite database file exists
    sqlite_path = config.get("sqlite", {}).get("db_path", "shadow.db")
    if os.path.exists(sqlite_path):
        return "sqlite"

    return "sqlite"


def create_backend(name, config):
    """
    Instantiate the right backend adapter.

    Each backend is imported lazily so we don't fail on missing dependencies
    for backends the user isn't using. (e.g., mysql-connector-python)

    The backend interface is two methods:

        .startup() â†’ str
            Returns identity text (soul, user context, rules).

        .search(query, n, category, full) â†’ list[dict]
            Returns ranked results. Each dict has:
            {id, score, title, summary, cat, src, content}

    Args:
        name:   "postgres", "pg", "sqlite", "mysql", or "mariadb"
        config: Full config dict from ~/.shadowdb.json

    Returns:
        An instantiated backend object.
    """
    name = (name or "sqlite").lower().strip()

    if name in ("postgres", "pg"):
        from backends.postgres import PostgresBackend
        pg = config.get("postgres", {})
        return PostgresBackend(
            psql_path=pg.get("psql_path", "/opt/homebrew/opt/postgresql@17/bin/psql"),
            database=pg.get("database", "shadow"),
            embedding_url=pg.get("embedding_url", "http://localhost:11434/api/embeddings"),
            embedding_model=pg.get("embedding_model", "nomic-embed-text"),
        )

    elif name == "sqlite":
        from backends.sqlite import SQLiteBackend
        sq = config.get("sqlite", {})
        return SQLiteBackend(
            db_path=sq.get("db_path", "shadow.db"),
            embedding_url=sq.get("embedding_url", "http://localhost:11434/api/embeddings"),
            embedding_model=sq.get("embedding_model", "nomic-embed-text"),
        )

    elif name in ("mysql", "mariadb"):
        from backends.mysql import MySQLBackend
        my = config.get("mysql", {})
        return MySQLBackend(
            host=my.get("host", "localhost"),
            port=my.get("port", 3306),
            user=my.get("user", "root"),
            password=my.get("password", ""),
            database=my.get("database", "shadow"),
            embedding_url=my.get("embedding_url", "http://localhost:11434/api/embeddings"),
            embedding_model=my.get("embedding_model", "nomic-embed-text"),
        )

    else:
        print(f"Unknown backend: {name}", file=sys.stderr)
        print("Supported: postgres, sqlite, mysql", file=sys.stderr)
        sys.exit(1)


# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                        DIRECT SQL HELPERS                                  â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
#   Subcommands (save, loops, state, people, handoff, d) talk directly to
#   PostgreSQL via psql. They bypass the backend adapter because they do
#   simple CRUD, not search.
#
#   Two helpers:
#
#     psql_cmd()    â€” Returns raw text (for parsing values)
#     psql_pretty() â€” Returns formatted table output (for display)


def psql_cmd(sql, database="shadow"):
    """
    Run a SQL query via psql and return the raw output as a string.

    Uses -t (tuples only, no headers) and -A (unaligned, no padding).
    This gives clean, parseable output â€” one value per line.

    Args:
        sql:      SQL query string.
        database: PostgreSQL database name (default: "shadow").

    Returns:
        str: Raw query output, stripped of whitespace.
    """
    config = load_config()
    psql_path = config.get("postgres", {}).get("psql_path",
        "/opt/homebrew/opt/postgresql@17/bin/psql")
    db = config.get("postgres", {}).get("database", database)

    result = subprocess.run(
        [psql_path, db, "-t", "-A", "-c", sql],
        capture_output=True,
        text=True,
        timeout=10,
    )
    return result.stdout.strip()


def psql_pretty(sql, database="shadow"):
    """
    Run a SQL query via psql and return formatted table output.

    Unlike psql_cmd(), this keeps headers and alignment â€” producing
    the familiar psql table format that's easy to read.

    Args:
        sql:      SQL query string.
        database: PostgreSQL database name (default: "shadow").

    Returns:
        str: Formatted table output.
    """
    config = load_config()
    psql_path = config.get("postgres", {}).get("psql_path",
        "/opt/homebrew/opt/postgresql@17/bin/psql")
    db = config.get("postgres", {}).get("database", database)

    result = subprocess.run(
        [psql_path, db, "-c", sql],
        capture_output=True,
        text=True,
        timeout=10,
    )
    return result.stdout.strip()


# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                         RESULT FORMATTING                                  â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


def format_results(results, as_json=False):
    """
    Format search results for output.

    Two modes:

        JSON mode (--json):
            Clean array of result objects. Used when other tools consume
            the output, or when the model wants structured data.

        Human mode (default):
            Formatted blocks with dividers, rank numbers, and category tags.
            Optimized for the model to parse quickly.

    Args:
        results:  List of result dicts from backend.search().
        as_json:  If True, output JSON; if False, human-readable.
    """
    if as_json:
        print(json.dumps(results, indent=2))
        return

    for i, result in enumerate(results):

        # Title fallback: prefer title â†’ source filename â†’ ID
        title = result["title"] or result["src"] or f"id:{result['id']}"

        print(f"\n{'â”€' * 50}")
        print(f" #{i + 1} {title} [{result['cat']}] score:{result['score']}")

        # Summary line â€” truncated to 120 chars (just enough for context)
        if result["summary"]:
            print(f" {result['summary'][:120]}")

        print(f"{'â”€' * 50}")
        print(result["content"])


# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                                                                            â•‘
# â•‘                            SUBCOMMANDS                                     â•‘
# â•‘                                                                            â•‘
# â•‘   These are shortcuts for common database operations. They bypass the      â•‘
# â•‘   search pipeline entirely â€” no embeddings, no FTS, just direct SQL.       â•‘
# â•‘                                                                            â•‘
# â•‘   Subcommands never print startup text (identity block). Only search       â•‘
# â•‘   queries get the identity injection.                                      â•‘
# â•‘                                                                            â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


def cmd_save(args):
    """
    Save a new record to the memories table.

    Usage:
        m save "title" "content"
        m save "title" "content" -c category
        m save "title" "content" -c category -t tag1,tag2,tag3

    Args:
        args: Remaining CLI arguments after "save".
              [0] = title (required)
              [1] = content (required)
              -c   = category (default: "general")
              -t   = comma-separated tags

    Example:
        m save "Meeting Notes" "Discussed Q3 roadmap" -c project -t meeting,roadmap
    """
    if len(args) < 2:
        print('Usage: m save "title" "content" [-c category] [-t tag1,tag2]')
        sys.exit(1)

    title = args[0]
    content = args[1]
    category = "general"
    tags = []

    # Parse optional flags
    i = 2
    while i < len(args):
        if args[i] == "-c" and i + 1 < len(args):
            category = args[i + 1]
            i += 2
        elif args[i] == "-t" and i + 1 < len(args):
            tags = args[i + 1].split(",")
            i += 2
        else:
            i += 1

    # Escape single quotes for SQL (prevents injection from content)
    escaped_title = title.replace("'", "''")
    escaped_content = content.replace("'", "''")

    # Build PostgreSQL array literal: ARRAY['tag1','tag2']
    if tags:
        tags_sql = "ARRAY[" + ",".join(f"'{t.strip()}'" for t in tags) + "]"
    else:
        tags_sql = "ARRAY[]::text[]"

    sql = (
        f"INSERT INTO memories (title, content, category, tags, created_at) "
        f"VALUES ('{escaped_title}', '{escaped_content}', '{category}', "
        f"{tags_sql}, now()) RETURNING id;"
    )

    record_id = psql_cmd(sql)
    print(f'Saved: id={record_id} title="{title}" category={category}')


def cmd_loops(args):
    """
    Show open loops, nags, and deadlines.

    Queries the open_loops table for items with status='open',
    sorted by urgency (nags first, then by due date).

    Usage:
        m loops

    Output columns:
        id          â€” Loop ID
        nag         â€” ğŸ”´ if nagging, âšª if passive
        due         â€” Due date (or â€” if none)
        description â€” First 100 chars of the loop description
    """
    print(psql_pretty(
        "SELECT id, "
        "  CASE WHEN nag THEN 'ğŸ”´' ELSE 'âšª' END AS nag, "
        "  COALESCE(due_date::text, 'â€”') AS due, "
        "  left(description, 100) AS description "
        "FROM open_loops "
        "WHERE status = 'open' "
        "ORDER BY nag DESC, due_date ASC NULLS LAST;"
    ))


def cmd_state(args):
    """
    Read or write session state.

    The session_state table is a key-value store for passing context
    between sessions. When a session ends, it writes its state here.
    The next session reads it on startup.

    Usage:
        m state                    â€” Show all state
        m state current_focus      â€” Read one key
        m state current_focus "Working on ShadowDB quickstart"  â€” Write

    Args:
        args: [] for read-all, [key] for read-one, [key, value] for write.
    """
    if len(args) == 0:
        # Show all state
        print(psql_pretty(
            "SELECT key, left(value, 120) AS value, "
            "  updated_at::timestamp(0) "
            "FROM session_state "
            "ORDER BY key;"
        ))

    elif len(args) == 1:
        # Read one key
        key = args[0]
        result = psql_cmd(
            f"SELECT value FROM session_state WHERE key = '{key}';"
        )
        print(result if result else f"No key '{key}'")

    else:
        # Write key=value (upsert)
        key = args[0]
        value = args[1].replace("'", "''")
        psql_cmd(
            f"INSERT INTO session_state (key, value, updated_at) "
            f"VALUES ('{key}', '{value}', now()) "
            f"ON CONFLICT (key) DO UPDATE "
            f"SET value = '{value}', updated_at = now();"
        )
        print(f"Updated: {key}")


def cmd_people(args):
    """
    Look up contacts in the people table.

    Usage:
        m people              â€” List first 20 contacts
        m people "Watson"     â€” Search by name, company, or notes

    The search is case-insensitive (ILIKE) and matches partial strings.
    "Wat" will find "Watson", "Watkins", etc.

    Args:
        args: [] for list, [name] for search.
    """
    if not args:
        print(psql_pretty(
            "SELECT name, company, role, phone, email "
            "FROM people "
            "ORDER BY name "
            "LIMIT 20;"
        ))
    else:
        query = args[0].replace("'", "''")
        print(psql_pretty(
            f"SELECT name, company, role, phone, email, notes "
            f"FROM people "
            f"WHERE name ILIKE '%{query}%' "
            f"   OR company ILIKE '%{query}%' "
            f"   OR notes ILIKE '%{query}%';"
        ))


def cmd_handoff(args):
    """
    Write session handoff state in one call.

    When a session is about to end (compaction, context limit, user leaves),
    it should call `m handoff` to persist its context for the next session.

    Usage:
        m handoff "current focus"
        m handoff "current focus" "pending drafts"
        m handoff "current focus" "pending drafts" "recent decisions"

    This writes up to 3 keys to session_state:
        current_focus    â€” What the session was working on
        pending_drafts   â€” Any unsent drafts awaiting approval
        recent_decisions â€” Key decisions made this session

    Args:
        args: [focus], or [focus, drafts], or [focus, drafts, decisions]
    """
    if len(args) < 1:
        print('Usage: m handoff "focus" ["drafts"] ["decisions"]')
        sys.exit(1)

    focus = args[0].replace("'", "''")
    psql_cmd(
        f"INSERT INTO session_state (key, value, updated_at) "
        f"VALUES ('current_focus', '{focus}', now()) "
        f"ON CONFLICT (key) DO UPDATE "
        f"SET value = '{focus}', updated_at = now();"
    )

    if len(args) > 1:
        drafts = args[1].replace("'", "''")
        psql_cmd(
            f"INSERT INTO session_state (key, value, updated_at) "
            f"VALUES ('pending_drafts', '{drafts}', now()) "
            f"ON CONFLICT (key) DO UPDATE "
            f"SET value = '{drafts}', updated_at = now();"
        )

    if len(args) > 2:
        decisions = args[2].replace("'", "''")
        psql_cmd(
            f"INSERT INTO session_state (key, value, updated_at) "
            f"VALUES ('recent_decisions', '{decisions}', now()) "
            f"ON CONFLICT (key) DO UPDATE "
            f"SET value = '{decisions}', updated_at = now();"
        )

    print("Session handoff written.")
    print(psql_pretty(
        "SELECT key, left(value, 100) AS value "
        "FROM session_state "
        "ORDER BY key;"
    ))


def cmd_d(args):
    """
    Daily dashboard â€” quick overview of everything.

    Combines three views in one call:

        1. SESSION STATE  â€” What's the current focus? Any pending drafts?
        2. OPEN LOOPS     â€” Nags, deadlines, things that need attention
        3. RECENT (24h)   â€” What was added to the knowledge base today

    Usage:
        m d

    This is what HEARTBEAT.md points to: `m d`. Every heartbeat poll
    runs this to check if anything needs attention.
    """
    print("â•â•â• SESSION STATE â•â•â•")
    print(psql_pretty(
        "SELECT key, left(value, 120) AS value "
        "FROM session_state "
        "ORDER BY key;"
    ))

    print("\nâ•â•â• OPEN LOOPS â•â•â•")
    print(psql_pretty(
        "SELECT id, "
        "  CASE WHEN nag THEN 'ğŸ”´' ELSE 'âšª' END AS nag, "
        "  COALESCE(due_date::text, 'â€”') AS due, "
        "  left(description, 100) AS description "
        "FROM open_loops "
        "WHERE status = 'open' "
        "ORDER BY nag DESC, due_date ASC NULLS LAST;"
    ))

    print("\nâ•â•â• RECENT (24h) â•â•â•")
    print(psql_pretty(
        "SELECT id, category, left(title, 60) AS title, "
        "  created_at::timestamp(0) "
        "FROM memories "
        "WHERE created_at > now() - interval '24 hours' "
        "ORDER BY created_at DESC "
        "LIMIT 10;"
    ))


# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                         SUBCOMMAND REGISTRY                                â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
#   Maps subcommand names to handler functions.
#
#   When the user types `m save ...`, we look up "save" in this dict
#   and call the handler directly â€” bypassing argument parsing and the
#   search pipeline entirely. This keeps subcommands fast (no backend
#   resolution, no embedding model load).

SUBCOMMANDS = {
    "save":    cmd_save,
    "loops":   cmd_loops,
    "state":   cmd_state,
    "people":  cmd_people,
    "handoff": cmd_handoff,
    "d":       cmd_d,
}


# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                                                                            â•‘
# â•‘                              MAIN                                          â•‘
# â•‘                                                                            â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


def main():
    """
    Entry point.

    Flow:
        1. No args or --help  â†’  print usage
        2. First arg is a subcommand  â†’  dispatch to handler
        3. Otherwise  â†’  treat as search query

    For search queries:
        1. Parse arguments (query, -n, -c, --full, --json, --backend)
        2. Resolve backend (4-step chain)
        3. Print startup identity text (if first query in session)
        4. Run hybrid search
        5. Format and print results
    """

    # â”€â”€ Help â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    if len(sys.argv) < 2 or sys.argv[1] in ("-h", "--help"):
        print("""m â€” ShadowDB memory search + operations

  SEARCH:   m "query" [-n 5] [-c category] [--full] [--json]
  SAVE:     m save "title" "content" [-c category] [-t tag1,tag2]
  LOOPS:    m loops                     â€” open nags/deadlines
  STATE:    m state [key] [value]       â€” read/write session state
  PEOPLE:   m people [name]             â€” contact lookup
  HANDOFF:  m handoff "focus" ["drafts"] ["decisions"]
  DASH:     m d                         â€” daily dashboard""")
        sys.exit(0)

    # â”€â”€ Subcommand dispatch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #
    #   If the first argument matches a subcommand, call it and exit.
    #   Subcommands never trigger startup text or search.

    if sys.argv[1] in SUBCOMMANDS:
        SUBCOMMANDS[sys.argv[1]](sys.argv[2:])
        sys.exit(0)

    # â”€â”€ Search mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #
    #   Everything that isn't a subcommand is treated as a search query.
    #   nargs="+" allows multi-word queries without quotes:
    #       m Dr Watson medical practice
    #   becomes the query: "Dr Watson medical practice"

    parser = argparse.ArgumentParser()

    parser.add_argument("query", nargs="+",
        help="Search query (quotes optional for multi-word)")

    parser.add_argument("-n", type=int, default=5,
        help="Number of results (default: 5)")

    parser.add_argument("-c", "--cat", default=None,
        help="Filter by category (e.g., contacts, cases)")

    parser.add_argument("--full", action="store_true",
        help="Return full content instead of summarized pyramid")

    parser.add_argument("--json", action="store_true",
        help="Output as JSON array")

    parser.add_argument("--backend", default=None,
        help="Force backend: postgres, sqlite, mysql")

    args = parser.parse_args()
    query = " ".join(args.query)

    # â”€â”€ Resolve backend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    backend = resolve_backend(args.backend)

    # â”€â”€ Startup identity â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #
    #   The startup table contains the agent's identity â€” who it is, who
    #   the user is, what rules to follow. This is printed before search
    #   results so the model reads its identity first.
    #
    #   If startup() fails (e.g., table doesn't exist yet), we continue
    #   silently. Search results are the primary value.

    try:
        startup_text = backend.startup()
        if startup_text:
            print(startup_text + "\n")
    except Exception:
        pass

    # â”€â”€ Search â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    results = backend.search(query, args.n, args.cat, args.full)
    format_results(results, args.json)


if __name__ == "__main__":
    main()
