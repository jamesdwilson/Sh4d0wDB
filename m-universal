#!/usr/bin/env python3
"""m — Universal ShadowDB memory search.

Supports multiple backends:
  - postgres: PostgreSQL + pgvector (hybrid FTS + vector + RRF)
  - sqlite:   SQLite + sqlite-vec (FTS5 + optional vector)
  - json:     Plain JSON file (keyword matching, zero dependencies)

Backend selection (in order):
  1. SHADOWDB_BACKEND env var (postgres|sqlite|json)
  2. Config file ~/.shadowdb.json: {"backend": "postgres", ...}
  3. Auto-detect: check for PG, then SQLite file, then JSON file

Usage: m "query" [-n 5] [-c category] [--full] [--json] [--backend postgres|sqlite|json]
"""
import argparse, json, os, sys

DEFAULT_CONFIG_PATH = os.path.expanduser("~/.shadowdb.json")

def load_config():
    """Load config from ~/.shadowdb.json if it exists."""
    if os.path.exists(DEFAULT_CONFIG_PATH):
        with open(DEFAULT_CONFIG_PATH) as f:
            return json.load(f)
    return {}

def resolve_backend(override=None):
    """Resolve which backend to use."""
    config = load_config()

    # 1. CLI override
    backend_name = override
    # 2. Env var
    if not backend_name:
        backend_name = os.environ.get("SHADOWDB_BACKEND")
    # 3. Config file
    if not backend_name:
        backend_name = config.get("backend")
    # 4. Auto-detect
    if not backend_name:
        backend_name = _auto_detect(config)

    return _create_backend(backend_name, config)

def _auto_detect(config):
    """Auto-detect available backend."""
    import subprocess
    # Check PostgreSQL
    psql = config.get("postgres", {}).get("psql_path", "psql")
    db = config.get("postgres", {}).get("database", "shadow")
    try:
        r = subprocess.run([psql, db, "-t", "-A", "-c", "SELECT 1;"],
                          capture_output=True, text=True, timeout=3)
        if r.returncode == 0:
            return "postgres"
    except:
        pass

    # Check SQLite file
    sqlite_path = config.get("sqlite", {}).get("db_path", "shadow.db")
    if os.path.exists(sqlite_path):
        return "sqlite"

    # Default to sqlite
    return "sqlite"

def _create_backend(name, config):
    """Instantiate the appropriate backend."""
    name = (name or "json").lower().strip()

    if name == "postgres" or name == "pg":
        from backends.postgres import PostgresBackend
        pg_cfg = config.get("postgres", {})
        return PostgresBackend(
            psql_path=pg_cfg.get("psql_path", "/opt/homebrew/opt/postgresql@17/bin/psql"),
            database=pg_cfg.get("database", "shadow"),
            embedding_url=pg_cfg.get("embedding_url", "http://localhost:11434/api/embeddings"),
            embedding_model=pg_cfg.get("embedding_model", "nomic-embed-text"),
        )

    elif name == "sqlite":
        from backends.sqlite import SQLiteBackend
        sq_cfg = config.get("sqlite", {})
        return SQLiteBackend(
            db_path=sq_cfg.get("db_path", "shadow.db"),
            embedding_url=sq_cfg.get("embedding_url", "http://localhost:11434/api/embeddings"),
            embedding_model=sq_cfg.get("embedding_model", "nomic-embed-text"),
        )

    elif name == "mysql" or name == "mariadb":
        from backends.mysql import MySQLBackend
        my_cfg = config.get("mysql", {})
        return MySQLBackend(
            host=my_cfg.get("host", "localhost"),
            port=my_cfg.get("port", 3306),
            user=my_cfg.get("user", "root"),
            password=my_cfg.get("password", ""),
            database=my_cfg.get("database", "shadow"),
            embedding_url=my_cfg.get("embedding_url", "http://localhost:11434/api/embeddings"),
            embedding_model=my_cfg.get("embedding_model", "nomic-embed-text"),
        )

    else:
        print(f"Unknown backend: {name}", file=sys.stderr)
        print("Supported: postgres, sqlite, mysql", file=sys.stderr)
        sys.exit(1)

def format_results(results, as_json=False):
    """Format search results for display."""
    if as_json:
        print(json.dumps(results, indent=2))
        return
    for i, r in enumerate(results):
        t = r["title"] or r["src"] or f"id:{r['id']}"
        print(f"\n{'─' * 50}")
        print(f" #{i+1} {t} [{r['cat']}] score:{r['score']}")
        if r["summary"]:
            print(f" {r['summary'][:120]}")
        print(f"{'─' * 50}")
        print(r["content"])

def main():
    if len(sys.argv) < 2 or sys.argv[1] in ["-h", "--help"]:
        print("m — ShadowDB memory search")
        print("  m \"query\" [-n 5] [-c category] [--full] [--json]")
        print("  m \"query\" --backend postgres|sqlite|mysql")
        print()
        print("Config: ~/.shadowdb.json")
        print("Env:    SHADOWDB_BACKEND=postgres|sqlite|json")
        sys.exit(0)

    ap = argparse.ArgumentParser()
    ap.add_argument("query", nargs="+")
    ap.add_argument("-n", type=int, default=5)
    ap.add_argument("-c", "--cat", default=None)
    ap.add_argument("--full", action="store_true")
    ap.add_argument("--json", action="store_true")
    ap.add_argument("--backend", default=None, help="postgres|sqlite|json")
    a = ap.parse_args()

    q = " ".join(a.query)
    backend = resolve_backend(a.backend)

    # Frontload startup/identity
    try:
        startup = backend.startup()
        if startup:
            print(startup + "\n")
    except:
        pass

    # Search
    results = backend.search(q, a.n, a.cat, a.full)
    format_results(results, a.json)

if __name__ == "__main__":
    main()
